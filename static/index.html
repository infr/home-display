<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Home Automation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg-color: #f3f4f6;
        --text-color: #1f2937;
        --border-color: #d1d5db;
        --input-bg: #ffffff;
        --sidebar-bg: #f3f4f6;
        --chart-bg: #f3f4f6;
        --chart-text: #1f2937;
        --chart-grid: #d1d5db;
      }

      :root.dark-mode {
        --bg-color: #1f2937;
        --text-color: #f3f4f6;
        --border-color: #4b5563;
        --input-bg: #374151;
        --sidebar-bg: #1f2937;
        --chart-bg: #1f2937;
        --chart-text: #f3f4f6;
        --chart-grid: #4b5563;
      }

      body,
      html {
        height: 100%;
        width: 100%;
        display: flex;
        font-family: Arial, sans-serif;
        background: var(--bg-color);
        color: var(--text-color);
        overflow: hidden;
      }

      .container {
        display: flex;
        width: 100%;
        height: 100%;
      }

      .sidebar {
        width: 33.33%;
        background: var(--sidebar-bg);
        border-radius: 8px;
        display: block;
        transition: background 0.5s ease;
        position: relative;
        z-index: 10;
      }

      .car {
        margin-top: 18px;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: none;
        border-radius: 0;
        box-shadow: none;
        padding: 0 0 10px 0;
        border-bottom: 1px solid var(--border-color);
      }

      .car:last-child {
        border-bottom: none;
      }

      .sidebar img {
        max-width: 150px;
        border-radius: 8px;
        display: block;
        transform-origin: center center;
        position: relative;
        z-index: 1000;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0;
        justify-items: stretch;
        align-items: stretch;
        width: 100%;
      }

      .control-button {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 8px;
        background-color: transparent;
        color: var(--text-color);
        font-size: 22px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s, color 0.2s;
        margin: 0;
        padding: 0;
        box-shadow: none;
        border: none;
      }
      .control-button:hover,
      .control-button:active {
        background: var(--border-color);
        color: var(--text-color);
      }

      .control-button i {
        color: var(--text-color);
      }

      .control-button.success {
        background-color: #28a745;
        animation: fadeToDefault 60s forwards;
      }

      .control-button.error {
        background-color: #fa8072;
        animation: fadeToDefault 60s forwards;
      }

      .control-button.spin {
        animation: spin 1s linear infinite;
      }

      @keyframes fadeToDefault {
        to {
          background-color: #5b5b5b;
        }
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .spin {
        animation: spin 5s linear;
      }

      @keyframes drive {
        0% {
          transform: translateX(0);
        }
        50% {
          transform: translateX(500px);
        }
        100% {
          transform: translateX(0);
        }
      }
      .drive {
        animation: drive 5s ease-in-out;
      }


      .iframe-container {
        width: 66.66%;
        border: none;
        background-color: var(--chart-bg);
        border-radius: 8px;
        box-shadow: none;
        margin-left: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
        z-index: 1;
      }

      #electricityChart {
        width: 100%;
        height: 100%;
      }

      .test-mode-indicator {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(239, 68, 68, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
        z-index: 10;
        display: none;
      }

      .test-mode-indicator.active {
        display: block;
      }

      .settings-button {
        position: fixed;
        top: 10px;
        right: 10px;
        font-size: 24px;
        cursor: pointer;
        z-index: 1000;
        background: transparent;
        border: none;
        padding: 5px;
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }

      .modal-content {
        background-color: var(--bg-color);
        margin: 10% auto;
        padding: 30px;
        border-radius: 8px;
        width: 400px;
        max-width: 90%;
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .modal-header h2 {
        margin: 0;
        color: var(--text-color);
      }

      .close {
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        color: var(--text-color);
      }

      .setting-item {
        margin-bottom: 20px;
      }

      .setting-item label {
        display: block;
        margin-bottom: 8px;
        color: var(--text-color);
        font-weight: bold;
      }

      .setting-item input[type="number"] {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--input-bg);
        color: var(--text-color);
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toggle input[type="checkbox"] {
        width: 20px;
        height: 20px;
      }

      .clock {
        font-family: Arial, sans-serif;
        font-size: 22px;
        font-weight: bold;
        color: var(--text-color);
        text-align: center;
        padding: 12px;
      }

      .weather {
        padding: 5px;
        border-radius: 10px;
        font-size: 12px;
        color: var(--text-color);
        display: flex;
        flex-direction: row;
        align-items: stretch;
        justify-content: center;
        gap: 4px;
        flex-wrap: nowrap;
        background: var(--sidebar-bg);
        box-shadow: none;
        margin-bottom: 10px;
        border: none;
      }
      .weather-card {
        background: var(--input-bg);
        color: var(--text-color);
        border-radius: 6px;
        box-shadow: none;
        padding: 4px 4px 2px 4px;
        border: none;
        min-width: 0;
        flex: 1 1 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }
      .weather-day {
        text-align: center;
        font-size: 11px;
        color: var(--text-color);
        margin-bottom: 1px;
        font-weight: bold;
      }
      .weather-icon {
        font-size: 16px;
        margin: 1px 0 1px 0;
        text-align: center;
      }
      .weather-temps {
        text-align: center;
        font-size: 12px;
        font-family: monospace;
        color: var(--text-color);
      }
      .weather-high {
        font-weight: bold;
        color: var(--text-color);
      }
      .weather-low {
        color: var(--text-color);
        opacity: 0.7;
        margin-left: 2px;
      }

      .sidebar-section {
        width: 100%;
        max-width: none;
        margin-left: 0;
        margin-right: 0;
        flex: none;
      }

      .sidebar-divider {
        border: none;
        border-top: 1.5px dotted #bbb;
        margin: 16px 0 8px 0;
        width: 100%;
        background: none;
        margin-left: 0;
        margin-right: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Car Control Column (1/3) -->
      <div class="sidebar">
        <div id="clock" class="clock"></div>
        <div id="weather" class="weather sidebar-section"></div>
        <div class="car sidebar-section">
          <img src="330.png" alt="BMW Photo" onclick="drive(this)" />
          <div class="controls">
            <div class="control-button" onclick="controlBMW('climate', this)">üî•</div>
            <div class="control-button" onclick="controlBMW('flash', this)">üí°</div>
            <div class="control-button" onclick="controlBMW('lock', this)">üîí</div>
            <div class="control-button" onclick="controlBMW('unlock', this)">üîì</div>
          </div>
        </div>
        <div class="car sidebar-section">
          <img src="outlander.png" alt="Outlander Photo" onclick="driveToChart(this)" />
          <div class="controls">
            <div class="control-button" onclick="controlOutlander('remoteHeating', this)">üî•</div>
            <div class="control-button" onclick="controlOutlander('lights', this)">üí°</div>
          </div>
        </div>
      </div>

      <!-- External Content Column (2/3) -->
      <div class="iframe-container" id="electricity-container">
        <div class="test-mode-indicator" id="testModeIndicator">TEST MODE</div>
        <canvas id="electricityChart"></canvas>
      </div>
    </div>

    <!-- Settings Button -->
    <button class="settings-button" onclick="openSettings()">‚öôÔ∏è</button>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Settings</h2>
          <span class="close" onclick="closeSettings()">&times;</span>
        </div>
        <div class="setting-item">
          <label class="toggle">
            <input type="checkbox" id="darkModeToggle" onchange="toggleDarkMode()">
            <span>Dark Mode</span>
          </label>
        </div>
        <div class="setting-item">
          <label for="maxValue">Max Price Value (c/kWh)</label>
          <input type="number" id="maxValue" value="30" min="10" max="100" onchange="updateMaxValue()">
        </div>
        <div class="setting-item">
          <label class="toggle">
            <input type="checkbox" id="testModeToggle" onchange="toggleTestMode()">
            <span>Test Mode (Random Data)</span>
          </label>
        </div>
      </div>
    </div>

    <script src="electricity.js"></script>

    <script>
      function spinit(element) {
        element.classList.remove('spin')
        void element.offsetWidth
        element.classList.add('spin')
      }
      function drive(element) {
        element.classList.remove('drive')
        void element.offsetWidth
        element.classList.add('drive')
      }

      let isAnimatingChart = false

      function driveToChart(element) {
        if (isAnimatingChart) return

        const canvas = document.getElementById('electricityChart')
        if (!canvas || typeof priceData === 'undefined' || !priceData.length) {
          drive(element)
          return
        }

        isAnimatingChart = true

        const chartRect = canvas.getBoundingClientRect()
        const carRect = element.getBoundingClientRect()

        const paddingLeft = 70
        const paddingRight = 20
        const paddingTop = 50
        const paddingBottom = 70

        // Use full canvas width, car can go beyond visible area
        const chartAreaLeft = chartRect.left
        const chartAreaRight = chartRect.right

        const duration = 12000
        const startTime = Date.now()

        // Get the data to display (same logic as in electricity.js)
        const now = new Date()
        let dataToShow = priceData.filter(price => {
          const priceDate = new Date(price.date)
          return priceDate >= now && priceDate < new Date(now.getTime() + 24 * 60 * 60 * 1000)
        }).slice(0, 96)

        const minPrice = 0
        const maxPrice = ELECTRICITY_CONFIG?.priceScale?.max || 30

        // Pre-calculate smoothed price values for performance
        const smoothedPrices = []
        for (let i = 0; i < dataToShow.length; i++) {
          const startIdx = Math.max(0, i - 3)
          const endIdx = Math.min(dataToShow.length - 1, i + 3)
          let sum = 0
          let count = 0
          for (let j = startIdx; j <= endIdx; j++) {
            sum += dataToShow[j]?.value || 15
            count++
          }
          smoothedPrices.push(sum / count)
        }

        const yHistory = []
        const rotationHistory = []

        // Calculate first bar position for initial drive
        const firstPriceValue = dataToShow[0]?.value || 15
        const chartHeightPx = canvas.height - paddingTop - paddingBottom
        let firstNormalizedHeight
        if (firstPriceValue < 0) {
          firstNormalizedHeight = 0
        } else if (firstPriceValue > maxPrice) {
          firstNormalizedHeight = 1
        } else {
          firstNormalizedHeight = firstPriceValue / maxPrice
        }
        const firstBarTopCanvas = paddingTop + chartHeightPx * (1 - firstNormalizedHeight)
        const firstBarScreenY = chartRect.top + (firstBarTopCanvas / canvas.height) * chartRect.height - element.offsetHeight

        // Track last position when leaving chart
        let lastChartX = 0
        let lastChartY = 0

        function animate() {
          const elapsed = Date.now() - startTime
          let progress = Math.min(elapsed / duration, 1)

          // Phase 1 (0-15%): Drive to start of chart
          // Phase 2 (15-85%): Drive across chart
          // Phase 3 (85-100%): Return home
          let xProgress, phase, direction = 1
          if (progress < 0.15) {
            phase = 'toStart'
            xProgress = 0
            direction = 1
          } else if (progress < 0.85) {
            phase = 'onChart'
            const chartProgress = (progress - 0.15) / 0.7
            if (chartProgress < 0.5) {
              xProgress = chartProgress * 2
              direction = 1
            } else {
              xProgress = 2 - chartProgress * 2
              direction = -1
            }
          } else {
            phase = 'returning'
            xProgress = 0
            direction = 1
          }

          let translateX, translateY, rotation = 0

          if (phase === 'toStart') {
            // Drive from original position to start of chart
            const phaseProgress = progress / 0.15
            const targetX = chartAreaLeft
            translateX = (targetX - carRect.left) * phaseProgress
            translateY = (firstBarScreenY - carRect.top) * phaseProgress

            // Calculate rotation based on the slope to first bar
            const deltaY = firstBarScreenY - carRect.top
            const deltaX = chartAreaLeft - carRect.left
            const targetRotation = Math.atan2(deltaY, deltaX * 0.5) * (180 / Math.PI)
            const clampedRotation = Math.max(-80, Math.min(80, targetRotation))

            // Gradually increase rotation from 0 to target as we progress
            const currentRotation = clampedRotation * phaseProgress

            // Smooth rotation on the way to first bar
            rotationHistory.push(currentRotation)
            if (rotationHistory.length > 12) rotationHistory.shift()
            let rotSum = 0
            for (let i = 0; i < rotationHistory.length; i++) {
              rotSum += rotationHistory[i]
            }
            rotation = rotSum / rotationHistory.length
          } else if (phase === 'onChart') {
            // On chart - follow the data
            const chartWidth = chartAreaRight - chartAreaLeft - element.offsetWidth
            const currentX = chartAreaLeft + chartWidth * xProgress

            // Use pre-calculated smoothed price
            const dataIndex = Math.floor(xProgress * (smoothedPrices.length - 1))
            const priceValue = smoothedPrices[dataIndex] || 15

            // Calculate Y position based on price
            let normalizedHeight
            if (priceValue < 0) {
              normalizedHeight = 0
            } else if (priceValue > maxPrice) {
              normalizedHeight = 1
            } else {
              normalizedHeight = priceValue / maxPrice
            }

            const barTopCanvas = paddingTop + chartHeightPx * (1 - normalizedHeight)

            // Smooth the Y position (reduced window for better performance)
            yHistory.push(barTopCanvas)
            if (yHistory.length > 15) yHistory.shift()

            // Simple average using stored sum for performance
            let ySum = 0
            for (let i = 0; i < yHistory.length; i++) {
              ySum += yHistory[i]
            }
            const smoothY = ySum / yHistory.length

            // Calculate rotation based on Y change
            if (yHistory.length >= 10) {
              const yChange = yHistory[yHistory.length - 1] - yHistory[yHistory.length - 10]
              rotation = Math.atan2(yChange * direction, 20) * (180 / Math.PI)
              rotation = Math.max(-80, Math.min(80, rotation))
            }

            // Smooth rotation (reduced window for better performance)
            rotationHistory.push(rotation)
            if (rotationHistory.length > 12) rotationHistory.shift()
            let rotSum = 0
            for (let i = 0; i < rotationHistory.length; i++) {
              rotSum += rotationHistory[i]
            }
            rotation = rotSum / rotationHistory.length

            // Convert canvas Y to screen Y
            const targetScreenY = chartRect.top + (smoothY / canvas.height) * chartRect.height - element.offsetHeight

            translateX = currentX - carRect.left
            translateY = targetScreenY - carRect.top

            // Save position at end of chart phase for return
            if (progress >= 0.84) {
              lastChartX = translateX
              lastChartY = translateY
            }
          } else {
            // Returning home - interpolate back from last chart position
            const returnProgress = (progress - 0.85) / 0.15
            translateX = lastChartX * (1 - returnProgress)
            translateY = lastChartY * (1 - returnProgress)

            // Gradually reduce rotation to 0 as we return home
            const deltaY = firstBarScreenY - carRect.top
            const deltaX = chartAreaLeft - carRect.left
            const initialRotation = Math.atan2(deltaY, deltaX * 0.5) * (180 / Math.PI)
            const clampedInitialRotation = Math.max(-80, Math.min(80, initialRotation))

            // Keep same rotation direction but fade to 0
            const targetRotation = clampedInitialRotation * (1 - returnProgress)

            // Smoothly return rotation to 0
            rotationHistory.push(targetRotation)
            if (rotationHistory.length > 12) rotationHistory.shift()
            let rotSum = 0
            for (let i = 0; i < rotationHistory.length; i++) {
              rotSum += rotationHistory[i]
            }
            rotation = rotSum / rotationHistory.length
          }

          element.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotation}deg)`

          if (progress < 1) {
            requestAnimationFrame(animate)
          } else {
            element.style.transform = ''
            isAnimatingChart = false
          }
        }

        animate()
      }

      // Settings management
      function loadSettings() {
        const darkMode = localStorage.getItem('darkMode') === 'true'
        const maxValue = parseInt(localStorage.getItem('maxValue')) || 30
        const testMode = localStorage.getItem('testMode') === 'true'

        if (darkMode) {
          document.documentElement.classList.add('dark-mode')
          document.getElementById('darkModeToggle').checked = true
        }
        document.getElementById('maxValue').value = maxValue
        document.getElementById('testModeToggle').checked = testMode

        // Show/hide test mode indicator
        const indicator = document.getElementById('testModeIndicator')
        if (testMode) {
          indicator.classList.add('active')
        } else {
          indicator.classList.remove('active')
        }

        // Update electricity config with colors
        if (typeof ELECTRICITY_CONFIG !== 'undefined') {
          ELECTRICITY_CONFIG.priceScale.max = maxValue
          ELECTRICITY_CONFIG.testMode = testMode
          ELECTRICITY_CONFIG.colors.background = darkMode ? '#1f2937' : '#f3f4f6'
          ELECTRICITY_CONFIG.colors.text = darkMode ? '#f3f4f6' : '#1f2937'
          ELECTRICITY_CONFIG.colors.grid = darkMode ? '#4b5563' : '#d1d5db'
        }
      }

      function openSettings() {
        document.getElementById('settingsModal').style.display = 'block'
      }

      function closeSettings() {
        document.getElementById('settingsModal').style.display = 'none'
      }

      function toggleDarkMode() {
        const isDark = document.getElementById('darkModeToggle').checked
        localStorage.setItem('darkMode', isDark)
        if (isDark) {
          document.documentElement.classList.add('dark-mode')
        } else {
          document.documentElement.classList.remove('dark-mode')
        }
        // Update chart colors
        if (typeof ELECTRICITY_CONFIG !== 'undefined') {
          ELECTRICITY_CONFIG.colors.background = isDark ? '#1f2937' : '#f3f4f6'
          ELECTRICITY_CONFIG.colors.text = isDark ? '#f3f4f6' : '#1f2937'
          ELECTRICITY_CONFIG.colors.grid = isDark ? '#4b5563' : '#d1d5db'
          if (typeof renderElectricityChart === 'function') {
            renderElectricityChart()
          }
        }
      }

      function updateMaxValue() {
        const maxValue = parseInt(document.getElementById('maxValue').value)
        localStorage.setItem('maxValue', maxValue)
        if (typeof ELECTRICITY_CONFIG !== 'undefined') {
          ELECTRICITY_CONFIG.priceScale.max = maxValue
          if (typeof renderElectricityChart === 'function') {
            renderElectricityChart()
          }
        }
      }

      function toggleTestMode() {
        const testMode = document.getElementById('testModeToggle').checked
        localStorage.setItem('testMode', testMode)

        // Show/hide test mode indicator
        const indicator = document.getElementById('testModeIndicator')
        if (testMode) {
          indicator.classList.add('active')
        } else {
          indicator.classList.remove('active')
        }

        if (typeof ELECTRICITY_CONFIG !== 'undefined') {
          ELECTRICITY_CONFIG.testMode = testMode
          if (typeof fetchElectricityPrices === 'function') {
            fetchElectricityPrices()
          }
        }
      }

      // Close modal when clicking outside
      window.onclick = function(event) {
        const modal = document.getElementById('settingsModal')
        if (event.target === modal) {
          closeSettings()
        }
      }

      // Load settings on page load
      loadSettings()

      function updateClock() {
        const clockElement = document.getElementById('clock')
        const now = new Date()

        const date = now.toLocaleDateString('FI-fi', {
          weekday: 'short',
          year: 'numeric',
          month: 'numeric',
          day: 'numeric',
        })

        const time = now.toLocaleTimeString('FI-fi', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
        })

        clockElement.textContent = `${date} ${time}`
      }

      setInterval(updateClock, 1000)

      async function initializeVIN() {
        let vin = localStorage.getItem('bmw_vin')
        if (!vin) {
          console.log('VIN not found in localStorage. Fetching VIN from API...')
          try {
            const response = await fetch('/bmw/list')
            const data = await response.json()

            if (data && data.output) {
              const match = data.output.match(/\((\w+)\)/)
              if (match) {
                vin = match[1]
                localStorage.setItem('bmw_vin', vin)
                console.log('VIN stored in localStorage:', vin)
              } else {
                throw new Error('VIN not found in response.')
              }
            }
          } catch (error) {
            console.error('Error fetching VIN:', error)
            document.getElementById('output').innerText = `Error fetching VIN: ${error.message}`
          }
        }
        return vin
      }

      function controlBMW(command, button) {
        initializeVIN().then(vin => {
          if (!vin) {
            console.error('VIN is missing. Unable to proceed with command.')
            return
          }

          button.classList.add('spin')

          fetch(`/bmw/${command}/${vin}`, { method: 'POST' })
            .then(response => response.json())
            .then(data => {
              button.classList.remove('spin')
              if (data.status === 'success') {
                setButtonState(button, 'success')
              } else {
                setButtonState(button, 'error')
                document.getElementById('output').innerText = `Command failed: ${JSON.stringify(data, null, 2)}`
              }
            })
            .catch(error => {
              button.classList.remove('spin')
              setButtonState(button, 'error')
              document.getElementById('output').innerText = `Error: ${error.message}`
            })
        })
      }

      function controlOutlander(command, button) {
        button.classList.add('spin')

        fetch(`/outlander/${command}`, { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            button.classList.remove('spin')
            if (data.status === 'success') {
              setButtonState(button, 'success')
            } else {
              setButtonState(button, 'error')
              document.getElementById('output').innerText = `Command failed: ${JSON.stringify(data, null, 2)}`
            }
          })
          .catch(error => {
            button.classList.remove('spin')
            setButtonState(button, 'error')
            document.getElementById('output').innerText = `Error: ${error.message}`
          })
      }

      function setButtonState(button, state) {
        button.classList.add(state)
        setTimeout(() => {
          button.classList.remove(state)
        }, 10000)
      }

      // Auto-refresh every hour
      setTimeout(() => {
        location.reload()
      }, 60 * 60 * 1000)

      // Weather configuration
      const WEATHER_LATITUDE = 60.2701
      const WEATHER_LONGITUDE = 24.7976
      const WEATHER_TIMEZONE = 'Europe/Helsinki'

      async function fetchWeather() {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${WEATHER_LATITUDE}&longitude=${WEATHER_LONGITUDE}&daily=temperature_2m_max,temperature_2m_min,weathercode&timezone=${encodeURIComponent(
          WEATHER_TIMEZONE
        )}&current_weather=true`
        try {
          const response = await fetch(url)
          const data = await response.json()
          if (!data.daily) return
          const days = data.daily
          const weatherCodes = days.weathercode
          const tempsMax = days.temperature_2m_max
          const tempsMin = days.temperature_2m_min
          const dates = days.time

          const icons = weatherCodes.map(code => weatherIcon(code))
          const dayNames = dates.map((d, i) =>
            i === 0 ? 'Today' : new Date(d).toLocaleDateString('en-US', { weekday: 'short' })
          )

          let html = ''
          if (data.current_weather && typeof data.current_weather.temperature === 'number') {
            html += `<div class="weather-card">
              <div class="weather-day">Now</div>
              <div class="weather-icon">${weatherIcon(data.current_weather.weathercode)}</div>
              <div class="weather-temps">
                <span class="weather-high">${Math.round(data.current_weather.temperature)}¬∞</span>
              </div>
            </div>`
          }
          for (let i = 0; i < 3; i++) {
            html += `<div class="weather-card">
              <div class="weather-day">${dayNames[i]}</div>
              <div class="weather-icon">${icons[i]}</div>
              <div class="weather-temps">
                <span class="weather-high">${Math.round(tempsMax[i])}¬∞</span>/<span class="weather-low">${Math.round(
              tempsMin[i]
            )}¬∞</span>
              </div>
            </div>`
          }
          document.getElementById('weather').innerHTML = html
        } catch (e) {
          document.getElementById('weather').innerHTML = '<span style="color:#a00">Weather unavailable</span>'
        }
      }

      // Open-Meteo weather codes: https://open-meteo.com/en/docs#api_form
      function weatherIcon(code) {
        if ([0].includes(code)) return '‚òÄÔ∏è' // Clear
        if ([1, 2, 3].includes(code)) return '‚õÖ' // Mainly clear/partly cloudy
        if ([45, 48].includes(code)) return 'üå´Ô∏è' // Fog
        if ([51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82].includes(code)) return 'üåßÔ∏è' // Rain
        if ([71, 73, 75, 77, 85, 86].includes(code)) return '‚ùÑÔ∏è' // Snow
        if ([95, 96, 99].includes(code)) return '‚õàÔ∏è' // Thunder
        return '‚òÅÔ∏è' // Default: Cloudy
      }

      initializeVIN()
      updateClock()
      fetchWeather()
    </script>
  </body>
</html>
