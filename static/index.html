<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Home Automation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg-color: #f3f4f6;
        --text-color: #1f2937;
        --border-color: #d1d5db;
        --input-bg: #ffffff;
        --sidebar-bg: #f3f4f6;
        --chart-bg: #f3f4f6;
        --chart-text: #1f2937;
        --chart-grid: #d1d5db;
      }

      :root.dark-mode {
        --bg-color: #1f2937;
        --text-color: #f3f4f6;
        --border-color: #4b5563;
        --input-bg: #374151;
        --sidebar-bg: #1f2937;
        --chart-bg: #1f2937;
        --chart-text: #f3f4f6;
        --chart-grid: #4b5563;
      }

      body,
      html {
        height: 100%;
        width: 100%;
        display: flex;
        font-family: Arial, sans-serif;
        background: var(--bg-color);
        color: var(--text-color);
        overflow: hidden;
      }

      .container {
        display: flex;
        width: 100%;
        height: 100%;
      }

      .sidebar {
        width: 33.33%;
        background: var(--sidebar-bg);
        border-radius: 8px;
        display: block;
        transition: background 0.5s ease;
        position: relative;
        z-index: 10;
      }

      .car {
        margin-top: 18px;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: none;
        border-radius: 0;
        box-shadow: none;
        padding: 0 0 10px 0;
        border-bottom: 1px solid var(--border-color);
      }

      .car:last-child {
        border-bottom: none;
      }

      .sidebar img {
        max-width: 150px;
        border-radius: 8px;
        display: block;
        transform-origin: center center;
        position: relative;
        z-index: 1000;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0;
        justify-items: stretch;
        align-items: stretch;
        width: 100%;
      }

      .control-button {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 8px;
        background-color: transparent;
        color: var(--text-color);
        font-size: 22px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s, color 0.2s;
        margin: 0;
        padding: 0;
        box-shadow: none;
        border: none;
      }
      .control-button:hover,
      .control-button:active {
        background: var(--border-color);
        color: var(--text-color);
      }

      .control-button i {
        color: var(--text-color);
      }

      .control-button.success {
        background-color: #28a745;
        animation: fadeToDefault 60s forwards;
      }

      .control-button.error {
        background-color: #fa8072;
        animation: fadeToDefault 60s forwards;
      }

      .control-button.spin {
        animation: spin 1s linear infinite;
      }

      @keyframes fadeToDefault {
        to {
          background-color: #5b5b5b;
        }
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .spin {
        animation: spin 5s linear;
      }

      @keyframes drive {
        0% {
          transform: translateX(0);
        }
        50% {
          transform: translateX(500px);
        }
        100% {
          transform: translateX(0);
        }
      }
      .drive {
        animation: drive 5s ease-in-out;
      }


      .iframe-container {
        width: 66.66%;
        border: none;
        background-color: var(--chart-bg);
        border-radius: 8px;
        box-shadow: none;
        margin-left: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: hidden;
        position: relative;
        z-index: 1;
      }

      #electricityChart {
        width: 100%;
        height: 100%;
      }

      .test-mode-indicator {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(239, 68, 68, 0.8);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-weight: bold;
        font-size: 14px;
        z-index: 10;
        display: none;
      }

      .test-mode-indicator.active {
        display: block;
      }

      .settings-button {
        position: fixed;
        top: 10px;
        right: 10px;
        font-size: 24px;
        cursor: pointer;
        z-index: 1000;
        background: transparent;
        border: none;
        padding: 5px;
      }

      .modal {
        display: none;
        position: fixed;
        z-index: 2000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }

      .modal-content {
        background-color: var(--bg-color);
        margin: 5% auto;
        padding: 30px;
        border-radius: 8px;
        width: 800px;
        max-width: 90%;
        max-height: 85vh;
        overflow-y: auto;
      }

      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
      }

      .modal-header h2 {
        margin: 0;
        color: var(--text-color);
      }

      .close {
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
        color: var(--text-color);
      }

      .modal-body {
        display: flex;
        gap: 30px;
      }

      .modal-column {
        flex: 1;
      }

      .modal-column.logs {
        flex: 1.2;
      }

      .setting-item {
        margin-bottom: 20px;
      }

      .setting-item label {
        display: block;
        margin-bottom: 8px;
        color: var(--text-color);
        font-weight: bold;
      }

      .setting-item input[type="number"],
      .setting-item select,
      .setting-item textarea {
        width: 100%;
        padding: 8px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background: var(--input-bg);
        color: var(--text-color);
        font-family: monospace;
        font-size: 12px;
      }

      .setting-item textarea {
        resize: vertical;
      }

      .toggle {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .toggle input[type="checkbox"] {
        width: 20px;
        height: 20px;
      }

      .clock {
        font-family: Arial, sans-serif;
        font-size: 22px;
        font-weight: bold;
        color: var(--text-color);
        text-align: center;
        padding: 12px;
      }

      .weather {
        padding: 5px;
        border-radius: 10px;
        font-size: 12px;
        color: var(--text-color);
        display: flex;
        flex-direction: row;
        align-items: stretch;
        justify-content: center;
        gap: 4px;
        flex-wrap: nowrap;
        background: var(--sidebar-bg);
        box-shadow: none;
        margin-bottom: 10px;
        border: none;
      }
      .weather-card {
        background: var(--input-bg);
        color: var(--text-color);
        border-radius: 6px;
        box-shadow: none;
        padding: 4px 4px 2px 4px;
        border: none;
        min-width: 0;
        flex: 1 1 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }
      .weather-day {
        text-align: center;
        font-size: 11px;
        color: var(--text-color);
        margin-bottom: 1px;
        font-weight: bold;
      }
      .weather-icon {
        font-size: 16px;
        margin: 1px 0 1px 0;
        text-align: center;
      }
      .weather-temps {
        text-align: center;
        font-size: 12px;
        font-family: monospace;
        color: var(--text-color);
      }
      .weather-high {
        font-weight: bold;
        color: var(--text-color);
      }
      .weather-low {
        color: var(--text-color);
        opacity: 0.7;
        margin-left: 2px;
      }

      .sidebar-section {
        width: 100%;
        max-width: none;
        margin-left: 0;
        margin-right: 0;
        flex: none;
      }

      .sidebar-divider {
        border: none;
        border-top: 1.5px dotted #bbb;
        margin: 16px 0 8px 0;
        width: 100%;
        background: none;
        margin-left: 0;
        margin-right: 0;
      }

      .car-left-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
        align-items: flex-start;
      }

      #bmwStatusInfo {
        display: flex;
        flex-direction: column;
        gap: 4px;
        align-items: flex-start;
      }

      .battery-bars {
        display: flex;
        gap: 2px;
      }

      .battery-bar {
        width: 10px;
        height: 16px;
        background: transparent;
        border: 1px solid var(--border-color);
        border-radius: 2px;
        transition: background 0.3s;
      }

      .battery-bar.active.low {
        background: #ef4444;
      }

      .battery-bar.active.medium {
        background: #f59e0b;
      }

      .battery-bar.active.high {
        background: #22c55e;
      }

      .charging-icon {
        font-size: 14px;
      }

      .charging-icon.charging {
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      .connection-status {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #22c55e;
      }

      .connection-status.disconnected {
        background: #9ca3af;
      }

      .connection-status.error {
        background: #fca5a5;
      }

      .car-with-range {
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .range-display {
        font-size: 10px;
        font-weight: bold;
        color: var(--text-color);
        text-align: left;
      }

      .lock-button.locked {
        color: #ef4444;
      }

      .lock-button.unlocked {
        color: #22c55e;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Car Control Column (1/3) -->
      <div class="sidebar">
        <div id="clock" class="clock"></div>
        <div id="weather" class="weather sidebar-section"></div>
        <div class="car sidebar-section">
          <div class="car-with-range">
            <div class="car-left-info">
              <div class="connection-status disconnected" id="bmwConnection"></div>
              <div id="bmwStatusInfo" style="display: none;">
                <div class="battery-bars" id="bmwBattery">
                  <div class="battery-bar"></div>
                  <div class="battery-bar"></div>
                  <div class="battery-bar"></div>
                  <div class="battery-bar"></div>
                  <div class="battery-bar"></div>
                  <div class="battery-bar"></div>
                </div>
                <div class="charging-icon" id="bmwCharging">🔌</div>
                <div class="range-display" id="bmwRange">-- km</div>
              </div>
            </div>
            <img src="330.png" alt="BMW Photo" onclick="drive(this)" />
          </div>
          <div class="controls">
            <div class="control-button" onclick="controlBMW('climate', this)">🔥</div>
            <div class="control-button" onclick="controlBMW('flash', this)">💡</div>
            <div class="control-button lock-button" id="bmwLockStatus" onclick="controlBMW('lock', this)">🔒</div>
            <div class="control-button" onclick="controlBMW('unlock', this)">🔓</div>
          </div>
        </div>
        <div class="car sidebar-section">
          <img src="outlander.png" alt="Outlander Photo" onclick="driveToChart(this)" />
          <div class="controls">
            <div class="control-button" onclick="controlOutlander('remoteHeating', this)">🔥</div>
            <div class="control-button" onclick="controlOutlander('lights', this)">💡</div>
          </div>
        </div>
      </div>

      <!-- External Content Column (2/3) -->
      <div class="iframe-container" id="electricity-container">
        <div class="test-mode-indicator" id="testModeIndicator">TEST MODE</div>
        <canvas id="electricityChart"></canvas>
      </div>
    </div>

    <!-- Settings Button -->
    <button class="settings-button" onclick="openSettings()">⚙️</button>

    <!-- Settings Modal -->
    <div id="settingsModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Settings</h2>
          <span class="close" onclick="closeSettings()">&times;</span>
        </div>
        <div class="modal-body">
          <div class="modal-column">
            <div class="setting-item">
              <label for="darkModeSelect">Theme</label>
              <select id="darkModeSelect" onchange="updateDarkMode()">
                <option value="light">Light</option>
                <option value="dark">Dark</option>
                <option value="auto">Auto (19:00-06:00)</option>
              </select>
            </div>
            <div class="setting-item">
              <label for="maxValue">Max Price Value (c/kWh)</label>
              <input type="number" id="maxValue" value="30" min="10" max="100" onchange="updateMaxValue()">
            </div>
            <div class="setting-item">
              <label class="toggle">
                <input type="checkbox" id="testModeToggle" onchange="toggleTestMode()">
                <span>Test Mode (Random Data)</span>
              </label>
            </div>
            <div class="setting-item">
              <button onclick="resetSettings()" style="padding: 8px 16px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-color); cursor: pointer; width: 100%;">Reset All Settings</button>
            </div>
          </div>
          <div class="modal-column logs">
            <div class="setting-item">
              <label for="output">Debug Log (last 10 entries)</label>
              <textarea id="output" readonly rows="12"></textarea>
              <button onclick="clearDebugLogs()" style="margin-top: 8px; padding: 8px 16px; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-color); cursor: pointer;">Clear Log</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script src="electricity.js"></script>

    <script>
      function spinit(element) {
        element.classList.remove('spin')
        void element.offsetWidth
        element.classList.add('spin')
      }
      function drive(element) {
        element.classList.remove('drive')
        void element.offsetWidth
        element.classList.add('drive')
      }

      let isAnimatingChart = false

      function driveToChart(element) {
        if (isAnimatingChart) return

        const canvas = document.getElementById('electricityChart')
        if (!canvas || typeof priceData === 'undefined' || !priceData.length) {
          drive(element)
          return
        }

        isAnimatingChart = true

        const chartRect = canvas.getBoundingClientRect()
        const carRect = element.getBoundingClientRect()

        const paddingLeft = 70
        const paddingRight = 20
        const paddingTop = 50
        const paddingBottom = 70

        // Use full canvas width, car can go beyond visible area
        const chartAreaLeft = chartRect.left
        const chartAreaRight = chartRect.right

        const duration = 12000
        const startTime = Date.now()

        // Get the data to display (same logic as in electricity.js)
        const now = new Date()
        let dataToShow = priceData.filter(price => {
          const priceDate = new Date(price.date)
          return priceDate >= now && priceDate < new Date(now.getTime() + 24 * 60 * 60 * 1000)
        }).slice(0, 96)

        const minPrice = 0
        const maxPrice = ELECTRICITY_CONFIG?.priceScale?.max || 30

        // Pre-calculate smoothed price values for performance
        const smoothedPrices = []
        for (let i = 0; i < dataToShow.length; i++) {
          const startIdx = Math.max(0, i - 3)
          const endIdx = Math.min(dataToShow.length - 1, i + 3)
          let sum = 0
          let count = 0
          for (let j = startIdx; j <= endIdx; j++) {
            sum += dataToShow[j]?.value || 15
            count++
          }
          smoothedPrices.push(sum / count)
        }

        const yHistory = []
        const rotationHistory = []

        // Calculate first bar position for initial drive
        const firstPriceValue = dataToShow[0]?.value || 15
        const chartHeightPx = canvas.height - paddingTop - paddingBottom
        let firstNormalizedHeight
        if (firstPriceValue < 0) {
          firstNormalizedHeight = 0
        } else if (firstPriceValue > maxPrice) {
          firstNormalizedHeight = 1
        } else {
          firstNormalizedHeight = firstPriceValue / maxPrice
        }
        const firstBarTopCanvas = paddingTop + chartHeightPx * (1 - firstNormalizedHeight)
        const firstBarScreenY = chartRect.top + (firstBarTopCanvas / canvas.height) * chartRect.height - element.offsetHeight

        // Track last position when leaving chart
        let lastChartX = 0
        let lastChartY = 0

        function animate() {
          const elapsed = Date.now() - startTime
          let progress = Math.min(elapsed / duration, 1)

          // Phase 1 (0-15%): Drive to start of chart
          // Phase 2 (15-85%): Drive across chart
          // Phase 3 (85-100%): Return home
          let xProgress, phase, direction = 1
          if (progress < 0.15) {
            phase = 'toStart'
            xProgress = 0
            direction = 1
          } else if (progress < 0.85) {
            phase = 'onChart'
            const chartProgress = (progress - 0.15) / 0.7
            if (chartProgress < 0.5) {
              xProgress = chartProgress * 2
              direction = 1
            } else {
              xProgress = 2 - chartProgress * 2
              direction = -1
            }
          } else {
            phase = 'returning'
            xProgress = 0
            direction = 1
          }

          let translateX, translateY, rotation = 0

          if (phase === 'toStart') {
            // Drive from original position to start of chart
            const phaseProgress = progress / 0.15
            const targetX = chartAreaLeft
            translateX = (targetX - carRect.left) * phaseProgress
            translateY = (firstBarScreenY - carRect.top) * phaseProgress

            // Calculate rotation based on the slope to first bar
            const deltaY = firstBarScreenY - carRect.top
            const deltaX = chartAreaLeft - carRect.left
            const targetRotation = Math.atan2(deltaY, deltaX * 0.5) * (180 / Math.PI)
            const clampedRotation = Math.max(-80, Math.min(80, targetRotation))

            // Gradually increase rotation from 0 to target as we progress
            const currentRotation = clampedRotation * phaseProgress

            // Smooth rotation on the way to first bar
            rotationHistory.push(currentRotation)
            if (rotationHistory.length > 12) rotationHistory.shift()
            let rotSum = 0
            for (let i = 0; i < rotationHistory.length; i++) {
              rotSum += rotationHistory[i]
            }
            rotation = rotSum / rotationHistory.length
          } else if (phase === 'onChart') {
            // On chart - follow the data
            const chartWidth = chartAreaRight - chartAreaLeft - element.offsetWidth
            const currentX = chartAreaLeft + chartWidth * xProgress

            // Use pre-calculated smoothed price
            const dataIndex = Math.floor(xProgress * (smoothedPrices.length - 1))
            const priceValue = smoothedPrices[dataIndex] || 15

            // Calculate Y position based on price
            let normalizedHeight
            if (priceValue < 0) {
              normalizedHeight = 0
            } else if (priceValue > maxPrice) {
              normalizedHeight = 1
            } else {
              normalizedHeight = priceValue / maxPrice
            }

            const barTopCanvas = paddingTop + chartHeightPx * (1 - normalizedHeight)

            // Smooth the Y position (reduced window for better performance)
            yHistory.push(barTopCanvas)
            if (yHistory.length > 15) yHistory.shift()

            // Simple average using stored sum for performance
            let ySum = 0
            for (let i = 0; i < yHistory.length; i++) {
              ySum += yHistory[i]
            }
            const smoothY = ySum / yHistory.length

            // Calculate rotation based on Y change
            if (yHistory.length >= 10) {
              const yChange = yHistory[yHistory.length - 1] - yHistory[yHistory.length - 10]
              rotation = Math.atan2(yChange * direction, 20) * (180 / Math.PI)
              rotation = Math.max(-80, Math.min(80, rotation))
            }

            // Smooth rotation (reduced window for better performance)
            rotationHistory.push(rotation)
            if (rotationHistory.length > 12) rotationHistory.shift()
            let rotSum = 0
            for (let i = 0; i < rotationHistory.length; i++) {
              rotSum += rotationHistory[i]
            }
            rotation = rotSum / rotationHistory.length

            // Convert canvas Y to screen Y
            const targetScreenY = chartRect.top + (smoothY / canvas.height) * chartRect.height - element.offsetHeight

            translateX = currentX - carRect.left
            translateY = targetScreenY - carRect.top

            // Save position at end of chart phase for return
            if (progress >= 0.84) {
              lastChartX = translateX
              lastChartY = translateY
            }
          } else {
            // Returning home - interpolate back from last chart position
            const returnProgress = (progress - 0.85) / 0.15
            translateX = lastChartX * (1 - returnProgress)
            translateY = lastChartY * (1 - returnProgress)

            // Gradually reduce rotation to 0 as we return home
            const deltaY = firstBarScreenY - carRect.top
            const deltaX = chartAreaLeft - carRect.left
            const initialRotation = Math.atan2(deltaY, deltaX * 0.5) * (180 / Math.PI)
            const clampedInitialRotation = Math.max(-80, Math.min(80, initialRotation))

            // Keep same rotation direction but fade to 0
            const targetRotation = clampedInitialRotation * (1 - returnProgress)

            // Smoothly return rotation to 0
            rotationHistory.push(targetRotation)
            if (rotationHistory.length > 12) rotationHistory.shift()
            let rotSum = 0
            for (let i = 0; i < rotationHistory.length; i++) {
              rotSum += rotationHistory[i]
            }
            rotation = rotSum / rotationHistory.length
          }

          element.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotation}deg)`

          if (progress < 1) {
            requestAnimationFrame(animate)
          } else {
            element.style.transform = ''
            isAnimatingChart = false
          }
        }

        animate()
      }

      // Debug logging to localStorage
      function addDebugLog(message) {
        const timestamp = new Date().toLocaleTimeString('fi-FI', { hour: '2-digit', minute: '2-digit', second: '2-digit' })
        const logEntry = `[${timestamp}] ${message}`

        // Get existing logs from localStorage
        let logs = []
        try {
          const stored = localStorage.getItem('debugLogs')
          if (stored) {
            logs = JSON.parse(stored)
          }
        } catch (e) {
          console.error('Error reading debug logs:', e)
        }

        // Add new log
        logs.push(logEntry)

        // Keep only last 10 logs
        if (logs.length > 10) {
          logs = logs.slice(-10)
        }

        // Save back to localStorage
        try {
          localStorage.setItem('debugLogs', JSON.stringify(logs))
        } catch (e) {
          console.error('Error saving debug logs:', e)
        }

        // Update textarea if it exists
        const output = document.getElementById('output')
        if (output) {
          output.value = logs.join('\n')
        }
      }

      function loadDebugLogs() {
        try {
          const stored = localStorage.getItem('debugLogs')
          if (stored) {
            const logs = JSON.parse(stored)
            const output = document.getElementById('output')
            if (output) {
              output.value = logs.join('\n')
            }
          }
        } catch (e) {
          console.error('Error loading debug logs:', e)
        }
      }

      function clearDebugLogs() {
        localStorage.removeItem('debugLogs')
        const output = document.getElementById('output')
        if (output) {
          output.value = ''
        }
      }

      function resetSettings() {
        if (confirm('Reset all settings to defaults?')) {
          localStorage.removeItem('themeMode')
          localStorage.removeItem('maxValue')
          localStorage.removeItem('testMode')
          localStorage.removeItem('bmw_vin')
          location.reload()
        }
      }

      // Settings management
      function isAutoDarkMode() {
        const now = new Date()
        const hour = now.getHours()
        return hour >= 19 || hour < 6
      }

      function applyTheme(isDark) {
        if (isDark) {
          document.documentElement.classList.add('dark-mode')
        } else {
          document.documentElement.classList.remove('dark-mode')
        }

        // Update chart colors
        if (typeof ELECTRICITY_CONFIG !== 'undefined') {
          ELECTRICITY_CONFIG.colors.background = isDark ? '#1f2937' : '#f3f4f6'
          ELECTRICITY_CONFIG.colors.text = isDark ? '#f3f4f6' : '#1f2937'
          ELECTRICITY_CONFIG.colors.grid = isDark ? '#4b5563' : '#d1d5db'
          if (typeof renderElectricityChart === 'function') {
            renderElectricityChart()
          }
        }
      }

      function loadSettings() {
        const themeMode = localStorage.getItem('themeMode') || 'auto'
        const maxValue = parseInt(localStorage.getItem('maxValue')) || 30
        const testMode = localStorage.getItem('testMode') === 'true'

        document.getElementById('darkModeSelect').value = themeMode
        document.getElementById('maxValue').value = maxValue
        document.getElementById('testModeToggle').checked = testMode

        // Apply theme based on mode
        if (themeMode === 'dark') {
          applyTheme(true)
        } else if (themeMode === 'auto') {
          applyTheme(isAutoDarkMode())
          // Check every minute if auto mode needs to update
          setInterval(() => {
            if (localStorage.getItem('themeMode') === 'auto') {
              applyTheme(isAutoDarkMode())
            }
          }, 60000)
        } else {
          applyTheme(false)
        }

        // Show/hide test mode indicator
        const indicator = document.getElementById('testModeIndicator')
        if (testMode) {
          indicator.classList.add('active')
        } else {
          indicator.classList.remove('active')
        }

        // Update electricity config
        if (typeof ELECTRICITY_CONFIG !== 'undefined') {
          ELECTRICITY_CONFIG.priceScale.max = maxValue
          ELECTRICITY_CONFIG.testMode = testMode
        }
      }

      function openSettings() {
        document.getElementById('settingsModal').style.display = 'block'
        loadDebugLogs()
      }

      function closeSettings() {
        document.getElementById('settingsModal').style.display = 'none'
      }

      function updateDarkMode() {
        const mode = document.getElementById('darkModeSelect').value
        localStorage.setItem('themeMode', mode)

        if (mode === 'dark') {
          applyTheme(true)
        } else if (mode === 'auto') {
          applyTheme(isAutoDarkMode())
        } else {
          applyTheme(false)
        }
      }

      function updateMaxValue() {
        const maxValue = parseInt(document.getElementById('maxValue').value)
        localStorage.setItem('maxValue', maxValue)
        if (typeof ELECTRICITY_CONFIG !== 'undefined') {
          ELECTRICITY_CONFIG.priceScale.max = maxValue
          if (typeof renderElectricityChart === 'function') {
            renderElectricityChart()
          }
        }
      }

      function toggleTestMode() {
        const testMode = document.getElementById('testModeToggle').checked
        localStorage.setItem('testMode', testMode)

        // Show/hide test mode indicator
        const indicator = document.getElementById('testModeIndicator')
        if (testMode) {
          indicator.classList.add('active')
        } else {
          indicator.classList.remove('active')
        }

        if (typeof ELECTRICITY_CONFIG !== 'undefined') {
          ELECTRICITY_CONFIG.testMode = testMode
          if (typeof fetchElectricityPrices === 'function') {
            fetchElectricityPrices()
          }
        }

        // Update BMW status with test data
        if (typeof updateBMWStatus === 'function') {
          updateBMWStatus()
        }
      }

      // Close modal when clicking outside
      window.onclick = function(event) {
        const modal = document.getElementById('settingsModal')
        if (event.target === modal) {
          closeSettings()
        }
      }

      // Load settings on page load
      loadSettings()

      function updateClock() {
        const clockElement = document.getElementById('clock')
        const now = new Date()

        const date = now.toLocaleDateString('FI-fi', {
          weekday: 'short',
          year: 'numeric',
          month: 'numeric',
          day: 'numeric',
        })

        const time = now.toLocaleTimeString('FI-fi', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
        })

        clockElement.textContent = `${date} ${time}`
      }

      setInterval(updateClock, 1000)

      async function initializeVIN() {
        let vin = localStorage.getItem('bmw_vin')
        if (!vin) {
          console.log('VIN not found in localStorage. Fetching VIN from API...')
          try {
            const response = await fetch('/bmw/list')
            const data = await response.json()

            if (data && data.output) {
              const match = data.output.match(/\((\w+)\)/)
              if (match) {
                vin = match[1]
                localStorage.setItem('bmw_vin', vin)
                console.log('VIN stored in localStorage:', vin)
              } else {
                throw new Error('VIN not found in response.')
              }
            }
          } catch (error) {
            console.error('Error fetching VIN:', error)
            addDebugLog(`[BMW] VIN fetch error: ${error.message}`)
          }
        }
        return vin
      }

      async function updateBMWStatus() {
        // Check if test mode is enabled
        const testMode = localStorage.getItem('testMode') === 'true'

        let batteryLevel, range, isLocked, isCharging, hasConnection

        if (testMode) {
          // Simulate random connection status (90% success, 10% failure)
          hasConnection = Math.random() > 0.1

          if (hasConnection) {
            // Generate random test data
            batteryLevel = Math.floor(Math.random() * 100)
            range = Math.floor(Math.random() * 400) + 50 // 50-450 km
            isLocked = Math.random() > 0.5
            isCharging = batteryLevel < 80 && Math.random() > 0.6
          }
        } else {
          const vin = await initializeVIN()
          if (!vin) {
            hasConnection = false
          } else {
            try {
              const response = await fetch(`/bmw/status/${vin}`, { method: 'POST' })
              const data = await response.json()

              if (data.status === 'success' && data.output) {
                hasConnection = true
                const output = data.output

                // Parse battery level (look for patterns like "battery: 85%" or "charge_level_hv: 85")
                const batteryMatch = output.match(/(?:battery|charge_level_hv|remaining_fuel).*?(\d+)/i)
                batteryLevel = batteryMatch ? parseInt(batteryMatch[1]) : 0

                // Parse range (look for patterns like "range: 350 km" or "remaining_range_electric: 350")
                const rangeMatch = output.match(/(?:range|remaining_range).*?(\d+)/i)
                range = rangeMatch ? parseInt(rangeMatch[1]) : 0

                // Parse lock status (look for "SECURED" or "UNLOCKED")
                isLocked = /SECURED|LOCKED/i.test(output)

                // Parse charging status (look for "CHARGING" or "charging_status")
                isCharging = /CHARGING|charging_status.*?CHARGING/i.test(output)
              } else {
                hasConnection = false
              }
            } catch (error) {
              console.error('Error fetching BMW status:', error)
              addDebugLog(`[BMW] Status fetch error: ${error.message}`)
              hasConnection = false
            }
          }
        }

        // Update connection status
        const connectionStatus = document.getElementById('bmwConnection')
        const statusInfo = document.getElementById('bmwStatusInfo')

        if (!hasConnection) {
          connectionStatus.classList.remove('disconnected')
          connectionStatus.classList.add('error')
          statusInfo.style.display = 'none'
          return
        }

        connectionStatus.classList.remove('disconnected', 'error')
        statusInfo.style.display = 'flex'

        // Update battery bars
        const batteryBars = document.querySelectorAll('#bmwBattery .battery-bar')
        const activeBars = Math.ceil((batteryLevel / 100) * 6)
        batteryBars.forEach((bar, index) => {
          bar.classList.remove('active', 'low', 'medium', 'high')
          if (index < activeBars) {
            bar.classList.add('active')
            if (batteryLevel <= 33) {
              bar.classList.add('low')
            } else if (batteryLevel <= 66) {
              bar.classList.add('medium')
            } else {
              bar.classList.add('high')
            }
          }
        })

        // Update charging icon
        const chargingIcon = document.getElementById('bmwCharging')
        chargingIcon.classList.remove('charging')
        if (isCharging) {
          chargingIcon.textContent = '⚡ Charging'
          chargingIcon.classList.add('charging')
        } else if (batteryLevel >= 90) {
          chargingIcon.textContent = '✓ Charged'
        } else {
          chargingIcon.textContent = '🔌 Not plugged'
        }

        // Update range
        document.getElementById('bmwRange').textContent = `${range} km`

        // Update lock status icon
        const lockButton = document.getElementById('bmwLockStatus')
        lockButton.classList.remove('locked', 'unlocked')
        if (isLocked) {
          lockButton.classList.add('locked')
          lockButton.textContent = '🔒'
        } else {
          lockButton.classList.add('unlocked')
          lockButton.textContent = '🔓'
        }
      }

      // Update BMW status every 5 minutes
      updateBMWStatus()
      setInterval(updateBMWStatus, 5 * 60 * 1000)

      function controlBMW(command, button) {
        initializeVIN().then(vin => {
          if (!vin) {
            console.error('VIN is missing. Unable to proceed with command.')
            return
          }

          button.classList.add('spin')

          fetch(`/bmw/${command}/${vin}`, { method: 'POST' })
            .then(response => response.json())
            .then(data => {
              button.classList.remove('spin')
              if (data.status === 'success') {
                setButtonState(button, 'success')
                // Refresh status after lock/unlock commands
                if (command === 'lock' || command === 'unlock') {
                  setTimeout(updateBMWStatus, 2000)
                }
              } else {
                setButtonState(button, 'error')
                addDebugLog(`[BMW] Command failed: ${JSON.stringify(data, null, 2)}`)
              }
            })
            .catch(error => {
              button.classList.remove('spin')
              setButtonState(button, 'error')
              addDebugLog(`[BMW] Error: ${error.message}`)
            })
        })
      }

      function controlOutlander(command, button) {
        button.classList.add('spin')

        fetch(`/outlander/${command}`, { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            button.classList.remove('spin')
            if (data.status === 'success') {
              setButtonState(button, 'success')
            } else {
              setButtonState(button, 'error')
              addDebugLog(`[Outlander] Command failed: ${JSON.stringify(data, null, 2)}`)
            }
          })
          .catch(error => {
            button.classList.remove('spin')
            setButtonState(button, 'error')
            addDebugLog(`[Outlander] Error: ${error.message}`)
          })
      }

      function setButtonState(button, state) {
        button.classList.add(state)
        setTimeout(() => {
          button.classList.remove(state)
        }, 10000)
      }

      // Auto-refresh every hour
      setTimeout(() => {
        location.reload()
      }, 60 * 60 * 1000)

      // Weather configuration
      const WEATHER_LATITUDE = 60.2701
      const WEATHER_LONGITUDE = 24.7976
      const WEATHER_TIMEZONE = 'Europe/Helsinki'

      async function fetchWeather() {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${WEATHER_LATITUDE}&longitude=${WEATHER_LONGITUDE}&daily=temperature_2m_max,temperature_2m_min,weathercode&timezone=${encodeURIComponent(
          WEATHER_TIMEZONE
        )}&current_weather=true`
        try {
          const response = await fetch(url)
          const data = await response.json()
          if (!data.daily) return
          const days = data.daily
          const weatherCodes = days.weathercode
          const tempsMax = days.temperature_2m_max
          const tempsMin = days.temperature_2m_min
          const dates = days.time

          const icons = weatherCodes.map(code => weatherIcon(code))
          const dayNames = dates.map((d, i) =>
            i === 0 ? 'Today' : new Date(d).toLocaleDateString('en-US', { weekday: 'short' })
          )

          let html = ''
          if (data.current_weather && typeof data.current_weather.temperature === 'number') {
            html += `<div class="weather-card">
              <div class="weather-day">Now</div>
              <div class="weather-icon">${weatherIcon(data.current_weather.weathercode)}</div>
              <div class="weather-temps">
                <span class="weather-high">${Math.round(data.current_weather.temperature)}°</span>
              </div>
            </div>`
          }
          for (let i = 0; i < 3; i++) {
            html += `<div class="weather-card">
              <div class="weather-day">${dayNames[i]}</div>
              <div class="weather-icon">${icons[i]}</div>
              <div class="weather-temps">
                <span class="weather-high">${Math.round(tempsMax[i])}°</span>/<span class="weather-low">${Math.round(
              tempsMin[i]
            )}°</span>
              </div>
            </div>`
          }
          document.getElementById('weather').innerHTML = html
        } catch (e) {
          document.getElementById('weather').innerHTML = '<span style="color:#a00">Weather unavailable</span>'
          addDebugLog(`[Weather] Fetch error: ${e.message}`)
        }
      }

      // Open-Meteo weather codes: https://open-meteo.com/en/docs#api_form
      function weatherIcon(code) {
        if ([0].includes(code)) return '☀️' // Clear
        if ([1, 2, 3].includes(code)) return '⛅' // Mainly clear/partly cloudy
        if ([45, 48].includes(code)) return '🌫️' // Fog
        if ([51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82].includes(code)) return '🌧️' // Rain
        if ([71, 73, 75, 77, 85, 86].includes(code)) return '❄️' // Snow
        if ([95, 96, 99].includes(code)) return '⛈️' // Thunder
        return '☁️' // Default: Cloudy
      }

      initializeVIN()
      updateClock()
      fetchWeather()
    </script>
  </body>
</html>
