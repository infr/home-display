<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Home Automation</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body,
      html {
        height: 100%;
        width: 100%;
        display: flex;
        font-family: Arial, sans-serif;
        background: #23272b;
        color: #fff;
      }

      .container {
        display: flex;
        width: 100%;
        height: 100%;
      }

      .sidebar {
        width: 33.33%;
        background: #23272b;
        border-radius: 8px;
        display: block;
        transition: background 0.5s ease;
        position: relative;
      }

      .car {
        margin-top: 18px;
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: none;
        border-radius: 0;
        box-shadow: none;
        padding: 0 0 10px 0;
      }

      .car:last-child {
        border-bottom: none;
      }

      .sidebar img {
        max-width: 150px;
        border-radius: 8px;
        display: block;
        transform-origin: center center;
      }

      .controls {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 0;
        justify-items: stretch;
        align-items: stretch;
        width: 100%;
      }

      .control-button {
        width: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 8px;
        background-color: #23272b;
        color: #fff;
        font-size: 22px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background 0.2s, color 0.2s;
        margin: 0;
        padding: 0;
        box-shadow: none;
        border: 1.5px solid #444;
      }
      .control-button:hover,
      .control-button:active {
        background: #1c69d4;
        color: #fff;
        border-color: #1c69d4;
      }

      .control-button i {
        color: #fff;
      }

      .control-button.success {
        background-color: #28a745;
        animation: fadeToDefault 60s forwards;
      }

      .control-button.error {
        background-color: #fa8072;
        animation: fadeToDefault 60s forwards;
      }

      .control-button.spin {
        animation: spin 1s linear infinite;
      }

      @keyframes fadeToDefault {
        to {
          background-color: #5b5b5b;
        }
      }

      @keyframes spin {
        from {
          transform: rotate(0deg);
        }
        to {
          transform: rotate(360deg);
        }
      }

      .spin {
        animation: spin 5s linear;
      }

      @keyframes drive {
        0% {
          transform: translateX(0);
        }
        50% {
          transform: translateX(500px);
        }
        100% {
          transform: translateX(0);
        }
      }
      .drive {
        animation: drive 5s ease-in-out;
      }


      .iframe-container {
        width: 66.66%;
        border: none;
        background-color: #23272b;
        border-radius: 8px;
        box-shadow: none;
        margin-left: 0;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      #electricityChart {
        width: 100%;
        height: 100%;
      }

      .clock {
        font-family: Arial, sans-serif;
        font-size: 22px;
        font-weight: bold;
        color: #fff;
        text-align: center;
        padding: 12px;
      }

      .weather {
        padding: 5px;
        border-radius: 10px;
        font-size: 12px;
        color: #fff;
        display: flex;
        flex-direction: row;
        align-items: stretch;
        justify-content: center;
        gap: 4px;
        flex-wrap: nowrap;
        background: #23272b;
        box-shadow: none;
        margin-bottom: 10px;
        border: none;
      }
      .weather-card {
        background: #ffffff;
        color: #000;
        border-radius: 6px;
        box-shadow: none;
        padding: 4px 4px 2px 4px;
        border: none;
        min-width: 0;
        flex: 1 1 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        font-size: 12px;
      }
      .weather-day {
        text-align: center;
        font-size: 11px;
        color: #666;
        margin-bottom: 1px;
        font-weight: bold;
      }
      .weather-icon {
        font-size: 16px;
        margin: 1px 0 1px 0;
        text-align: center;
      }
      .weather-temps {
        text-align: center;
        font-size: 12px;
        font-family: monospace;
        color: #000;
      }
      .weather-high {
        font-weight: bold;
        color: #000;
      }
      .weather-low {
        color: #666;
        margin-left: 2px;
      }

      .sidebar-section {
        width: 100%;
        max-width: none;
        margin-left: 0;
        margin-right: 0;
        flex: none;
      }

      .sidebar-divider {
        border: none;
        border-top: 1.5px dotted #bbb;
        margin: 16px 0 8px 0;
        width: 100%;
        background: none;
        margin-left: 0;
        margin-right: 0;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- Car Control Column (1/3) -->
      <div class="sidebar">
        <div id="clock" class="clock"></div>
        <div id="weather" class="weather sidebar-section"></div>
        <div class="car sidebar-section">
          <img src="330.png" alt="BMW Photo" onclick="drive(this)" />
          <div class="controls">
            <div class="control-button" onclick="controlBMW('climate', this)">üî•</div>
            <div class="control-button" onclick="controlBMW('flash', this)">üí°</div>
            <div class="control-button" onclick="controlBMW('lock', this)">üîí</div>
            <div class="control-button" onclick="controlBMW('unlock', this)">üîì</div>
          </div>
        </div>
        <div class="car sidebar-section">
          <img src="outlander.png" alt="Outlander Photo" onclick="driveToChart(this)" />
          <div class="controls">
            <div class="control-button" onclick="controlOutlander('remoteHeating', this)">üî•</div>
            <div class="control-button" onclick="controlOutlander('lights', this)">üí°</div>
          </div>
        </div>
      </div>

      <!-- External Content Column (2/3) -->
      <div class="iframe-container" id="electricity-container">
        <canvas id="electricityChart"></canvas>
      </div>
    </div>
    <script src="electricity.js"></script>

    <script>
      function spinit(element) {
        element.classList.remove('spin')
        void element.offsetWidth
        element.classList.add('spin')
      }
      function drive(element) {
        element.classList.remove('drive')
        void element.offsetWidth
        element.classList.add('drive')
      }

      let isAnimatingChart = false

      function driveToChart(element) {
        if (isAnimatingChart) return

        const canvas = document.getElementById('electricityChart')
        if (!canvas || typeof priceData === 'undefined' || !priceData.length) {
          drive(element)
          return
        }

        isAnimatingChart = true

        const chartRect = canvas.getBoundingClientRect()
        const carRect = element.getBoundingClientRect()

        const paddingLeft = 70
        const paddingRight = 20
        const paddingTop = 50
        const paddingBottom = 70

        // Use full canvas width, car can go beyond visible area
        const chartAreaLeft = chartRect.left
        const chartAreaRight = chartRect.right

        const duration = 12000
        const startTime = Date.now()

        // Get the data to display (same logic as in electricity.js)
        const now = new Date()
        let dataToShow = priceData.filter(price => {
          const priceDate = new Date(price.date)
          return priceDate >= now && priceDate < new Date(now.getTime() + 24 * 60 * 60 * 1000)
        }).slice(0, 96)

        const minPrice = 0
        const maxPrice = 30
        const yHistory = []
        const rotationHistory = []

        // Calculate first bar position for initial drive
        const firstPriceValue = dataToShow[0]?.value || 15
        const chartHeightPx = canvas.height - paddingTop - paddingBottom
        let firstNormalizedHeight
        if (firstPriceValue < 0) {
          firstNormalizedHeight = 0
        } else if (firstPriceValue > maxPrice) {
          firstNormalizedHeight = 1
        } else {
          firstNormalizedHeight = firstPriceValue / maxPrice
        }
        const firstBarTopCanvas = paddingTop + chartHeightPx * (1 - firstNormalizedHeight)
        const firstBarScreenY = chartRect.top + (firstBarTopCanvas / canvas.height) * chartRect.height - element.offsetHeight

        function animate() {
          const elapsed = Date.now() - startTime
          let progress = Math.min(elapsed / duration, 1)

          // Phase 1 (0-15%): Drive to start of chart
          // Phase 2 (15-85%): Drive across chart
          // Phase 3 (85-100%): Return home
          let xProgress, phase, direction = 1
          if (progress < 0.15) {
            phase = 'toStart'
            xProgress = 0
            direction = 1
          } else if (progress < 0.85) {
            phase = 'onChart'
            const chartProgress = (progress - 0.15) / 0.7
            if (chartProgress < 0.5) {
              xProgress = chartProgress * 2
              direction = 1
            } else {
              xProgress = 2 - chartProgress * 2
              direction = -1
            }
          } else {
            phase = 'returning'
            xProgress = 0
            direction = 1
          }

          let translateX, translateY, rotation = 0

          if (phase === 'toStart') {
            // Drive from original position to start of chart
            const phaseProgress = progress / 0.15
            const targetX = chartAreaLeft
            translateX = (targetX - carRect.left) * phaseProgress
            translateY = (firstBarScreenY - carRect.top) * phaseProgress

            // Calculate rotation based on the slope to first bar
            const deltaY = firstBarScreenY - carRect.top
            const deltaX = chartAreaLeft - carRect.left
            const targetRotation = Math.atan2(deltaY, deltaX * 0.5) * (180 / Math.PI)
            const clampedRotation = Math.max(-80, Math.min(80, targetRotation))

            // Gradually increase rotation from 0 to target as we progress
            const currentRotation = clampedRotation * phaseProgress

            // Smooth rotation on the way to first bar
            rotationHistory.push(currentRotation)
            if (rotationHistory.length > 20) rotationHistory.shift()
            rotation = rotationHistory.reduce((a, b) => a + b, 0) / rotationHistory.length
          } else if (phase === 'onChart') {
            // On chart - follow the data
            const chartWidth = chartAreaRight - chartAreaLeft - element.offsetWidth
            const currentX = chartAreaLeft + chartWidth * xProgress

            // Map xProgress to data index and sample surrounding data for smoothing
            const exactIndex = xProgress * (dataToShow.length - 1)
            const startIndex = Math.max(0, Math.floor(exactIndex) - 5)
            const endIndex = Math.min(dataToShow.length - 1, Math.ceil(exactIndex) + 5)

            // Get average price around current position for smoothing
            let priceSum = 0
            let priceCount = 0
            for (let i = startIndex; i <= endIndex; i++) {
              priceSum += dataToShow[i]?.value || 15
              priceCount++
            }
            const priceValue = priceSum / priceCount

            // Calculate Y position based on price
            let normalizedHeight
            if (priceValue < 0) {
              normalizedHeight = 0
            } else if (priceValue > maxPrice) {
              normalizedHeight = 1
            } else {
              normalizedHeight = priceValue / maxPrice
            }

            const barTopCanvas = paddingTop + chartHeightPx * (1 - normalizedHeight)

            // Smooth the Y position
            yHistory.push(barTopCanvas)
            if (yHistory.length > 25) yHistory.shift()
            const smoothY = yHistory.reduce((a, b) => a + b, 0) / yHistory.length

            // Calculate rotation based on Y change
            if (yHistory.length >= 15) {
              const recent = yHistory.slice(-15)
              const yChange = recent[recent.length - 1] - recent[0]
              // Positive yChange means going down (higher Y), negative means going up
              // When going backwards (direction = -1), invert the rotation
              rotation = Math.atan2(yChange * direction, 20) * (180 / Math.PI)
              rotation = Math.max(-80, Math.min(80, rotation))
            }

            // Smooth rotation
            rotationHistory.push(rotation)
            if (rotationHistory.length > 20) rotationHistory.shift()
            rotation = rotationHistory.reduce((a, b) => a + b, 0) / rotationHistory.length

            // Convert canvas Y to screen Y
            const targetScreenY = chartRect.top + (smoothY / canvas.height) * chartRect.height - element.offsetHeight

            translateX = currentX - carRect.left
            translateY = targetScreenY - carRect.top
          } else {
            // Returning home - interpolate back
            const returnProgress = (progress - 0.85) / 0.15
            const lastX = chartAreaLeft - carRect.left
            const lastY = firstBarScreenY - carRect.top
            translateX = lastX * (1 - returnProgress)
            translateY = lastY * (1 - returnProgress)

            // Smoothly return rotation to 0
            const targetRotation = 0
            rotationHistory.push(targetRotation)
            if (rotationHistory.length > 20) rotationHistory.shift()
            rotation = rotationHistory.reduce((a, b) => a + b, 0) / rotationHistory.length
          }

          element.style.transform = `translate(${translateX}px, ${translateY}px) rotate(${rotation}deg)`

          if (progress < 1) {
            requestAnimationFrame(animate)
          } else {
            element.style.transform = ''
            isAnimatingChart = false
          }
        }

        animate()
      }

      function updateClock() {
        const clockElement = document.getElementById('clock')
        const now = new Date()

        const date = now.toLocaleDateString('FI-fi', {
          weekday: 'short',
          year: 'numeric',
          month: 'numeric',
          day: 'numeric',
        })

        const time = now.toLocaleTimeString('FI-fi', {
          hour: '2-digit',
          minute: '2-digit',
          second: '2-digit',
        })

        clockElement.textContent = `${date} ${time}`
      }

      setInterval(updateClock, 1000)

      async function initializeVIN() {
        let vin = localStorage.getItem('bmw_vin')
        if (!vin) {
          console.log('VIN not found in localStorage. Fetching VIN from API...')
          try {
            const response = await fetch('/bmw/list')
            const data = await response.json()

            if (data && data.output) {
              const match = data.output.match(/\((\w+)\)/)
              if (match) {
                vin = match[1]
                localStorage.setItem('bmw_vin', vin)
                console.log('VIN stored in localStorage:', vin)
              } else {
                throw new Error('VIN not found in response.')
              }
            }
          } catch (error) {
            console.error('Error fetching VIN:', error)
            document.getElementById('output').innerText = `Error fetching VIN: ${error.message}`
          }
        }
        return vin
      }

      function controlBMW(command, button) {
        initializeVIN().then(vin => {
          if (!vin) {
            console.error('VIN is missing. Unable to proceed with command.')
            return
          }

          button.classList.add('spin')

          fetch(`/bmw/${command}/${vin}`, { method: 'POST' })
            .then(response => response.json())
            .then(data => {
              button.classList.remove('spin')
              if (data.status === 'success') {
                setButtonState(button, 'success')
              } else {
                setButtonState(button, 'error')
                document.getElementById('output').innerText = `Command failed: ${JSON.stringify(data, null, 2)}`
              }
            })
            .catch(error => {
              button.classList.remove('spin')
              setButtonState(button, 'error')
              document.getElementById('output').innerText = `Error: ${error.message}`
            })
        })
      }

      function controlOutlander(command, button) {
        button.classList.add('spin')

        fetch(`/outlander/${command}`, { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            button.classList.remove('spin')
            if (data.status === 'success') {
              setButtonState(button, 'success')
            } else {
              setButtonState(button, 'error')
              document.getElementById('output').innerText = `Command failed: ${JSON.stringify(data, null, 2)}`
            }
          })
          .catch(error => {
            button.classList.remove('spin')
            setButtonState(button, 'error')
            document.getElementById('output').innerText = `Error: ${error.message}`
          })
      }

      function setButtonState(button, state) {
        button.classList.add(state)
        setTimeout(() => {
          button.classList.remove(state)
        }, 10000)
      }

      // Auto-refresh every hour
      setTimeout(() => {
        location.reload()
      }, 60 * 60 * 1000)

      // Weather configuration
      const WEATHER_LATITUDE = 60.2701
      const WEATHER_LONGITUDE = 24.7976
      const WEATHER_TIMEZONE = 'Europe/Helsinki'

      async function fetchWeather() {
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${WEATHER_LATITUDE}&longitude=${WEATHER_LONGITUDE}&daily=temperature_2m_max,temperature_2m_min,weathercode&timezone=${encodeURIComponent(
          WEATHER_TIMEZONE
        )}&current_weather=true`
        try {
          const response = await fetch(url)
          const data = await response.json()
          if (!data.daily) return
          const days = data.daily
          const weatherCodes = days.weathercode
          const tempsMax = days.temperature_2m_max
          const tempsMin = days.temperature_2m_min
          const dates = days.time

          const icons = weatherCodes.map(code => weatherIcon(code))
          const dayNames = dates.map((d, i) =>
            i === 0 ? 'Today' : new Date(d).toLocaleDateString('en-US', { weekday: 'short' })
          )

          let html = ''
          if (data.current_weather && typeof data.current_weather.temperature === 'number') {
            html += `<div class="weather-card">
              <div class="weather-day">Now</div>
              <div class="weather-icon">${weatherIcon(data.current_weather.weathercode)}</div>
              <div class="weather-temps">
                <span class="weather-high">${Math.round(data.current_weather.temperature)}¬∞</span>
              </div>
            </div>`
          }
          for (let i = 0; i < 3; i++) {
            html += `<div class="weather-card">
              <div class="weather-day">${dayNames[i]}</div>
              <div class="weather-icon">${icons[i]}</div>
              <div class="weather-temps">
                <span class="weather-high">${Math.round(tempsMax[i])}¬∞</span>/<span class="weather-low">${Math.round(
              tempsMin[i]
            )}¬∞</span>
              </div>
            </div>`
          }
          document.getElementById('weather').innerHTML = html
        } catch (e) {
          document.getElementById('weather').innerHTML = '<span style="color:#a00">Weather unavailable</span>'
        }
      }

      // Open-Meteo weather codes: https://open-meteo.com/en/docs#api_form
      function weatherIcon(code) {
        if ([0].includes(code)) return '‚òÄÔ∏è' // Clear
        if ([1, 2, 3].includes(code)) return '‚õÖ' // Mainly clear/partly cloudy
        if ([45, 48].includes(code)) return 'üå´Ô∏è' // Fog
        if ([51, 53, 55, 56, 57, 61, 63, 65, 66, 67, 80, 81, 82].includes(code)) return 'üåßÔ∏è' // Rain
        if ([71, 73, 75, 77, 85, 86].includes(code)) return '‚ùÑÔ∏è' // Snow
        if ([95, 96, 99].includes(code)) return '‚õàÔ∏è' // Thunder
        return '‚òÅÔ∏è' // Default: Cloudy
      }

      initializeVIN()
      updateClock()
      fetchWeather()
    </script>
  </body>
</html>
